// This file has been automatically generated by capnp-es.
import * as $ from "capnp-es";
export const _capnpFileId = BigInt("0xe6afd26682091c01");
/**
* Top-level configuration for a workerd instance.
* */
export class Config extends $.Struct {
  static _capnp = {
    displayName: "Config",
    id: "8794486c76aaa7d6",
    size: new $.ObjectSize(0, 5)
  };
  static _Services;
  static _Sockets;
  static _Extensions;
  _adoptServices(value) {
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownServices() {
    return $.utils.disown(this.services);
  }
  /**
  * List of named services defined by this server. These names are private; they are only used
  * to refer to the services from elsewhere in this config file, as well as for logging and the
  * like. Services are not reachable until you configure some way to make them reachable, such
  * as via a Socket.
  *
  * If you do not define any service called "internet", one is defined implicitly, representing
  * the ability to access public internet servers. An explicit definition would look like:
  *
  *     ( name = "internet",
  *       network = (
  *         allow = ["public"],   # Allows connections to publicly-routable addresses only.
  *         tlsOptions = (trustBrowserCas = true)
  *       )
  *     )
  *
  * The "internet" service backs the global `fetch()` function in a Worker, unless that Worker's
  * configuration specifies some other service using the `globalOutbound` setting.
  * */
  get services() {
    return $.utils.getList(0, Config._Services, this);
  }
  _hasServices() {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initServices(length) {
    return $.utils.initList(0, Config._Services, length, this);
  }
  set services(value) {
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  _adoptSockets(value) {
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownSockets() {
    return $.utils.disown(this.sockets);
  }
  /**
  * List of sockets on which this server will listen, and the services that will be exposed
  * through them.
  * */
  get sockets() {
    return $.utils.getList(1, Config._Sockets, this);
  }
  _hasSockets() {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initSockets(length) {
    return $.utils.initList(1, Config._Sockets, length, this);
  }
  set sockets(value) {
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  _adoptV8Flags(value) {
    $.utils.adopt(value, $.utils.getPointer(2, this));
  }
  _disownV8Flags() {
    return $.utils.disown(this.v8Flags);
  }
  /**
  * List of "command-line" flags to pass to V8, like "--expose-gc". We put these in the config
  * rather than on the actual command line because for most use cases, managing these via the
  * config file is probably cleaner and easier than passing on the actual CLI.
  *
  * WARNING: Use at your own risk. V8 flags can have all sorts of wild effects including completely
  *   breaking everything. V8 flags also generally do not come with any guarantee of stability
  *   between V8 versions. Most users should not set any V8 flags.
  * */
  get v8Flags() {
    return $.utils.getList(2, $.TextList, this);
  }
  _hasV8Flags() {
    return !$.utils.isNull($.utils.getPointer(2, this));
  }
  _initV8Flags(length) {
    return $.utils.initList(2, $.TextList, length, this);
  }
  set v8Flags(value) {
    $.utils.copyFrom(value, $.utils.getPointer(2, this));
  }
  _adoptExtensions(value) {
    $.utils.adopt(value, $.utils.getPointer(3, this));
  }
  _disownExtensions() {
    return $.utils.disown(this.extensions);
  }
  /**
  * Extensions provide capabilities to all workers. Extensions are usually prepared separately
  * and are late-linked with the app using this config field.
  * */
  get extensions() {
    return $.utils.getList(3, Config._Extensions, this);
  }
  _hasExtensions() {
    return !$.utils.isNull($.utils.getPointer(3, this));
  }
  _initExtensions(length) {
    return $.utils.initList(3, Config._Extensions, length, this);
  }
  set extensions(value) {
    $.utils.copyFrom(value, $.utils.getPointer(3, this));
  }
  _adoptAutogates(value) {
    $.utils.adopt(value, $.utils.getPointer(4, this));
  }
  _disownAutogates() {
    return $.utils.disown(this.autogates);
  }
  /**
  * A list of gates which are enabled.
  * These are used to gate features/changes in workerd and in our internal repo. See the equivalent
  * config definition in our internal repo for more details.
  * */
  get autogates() {
    return $.utils.getList(4, $.TextList, this);
  }
  _hasAutogates() {
    return !$.utils.isNull($.utils.getPointer(4, this));
  }
  _initAutogates(length) {
    return $.utils.initList(4, $.TextList, length, this);
  }
  set autogates(value) {
    $.utils.copyFrom(value, $.utils.getPointer(4, this));
  }
  toString() {
    return "Config_" + super.toString();
  }
}
export class Socket_Https extends $.Struct {
  static _capnp = {
    displayName: "https",
    id: "de123876383cbbdc",
    size: new $.ObjectSize(8, 5)
  };
  _adoptOptions(value) {
    $.utils.adopt(value, $.utils.getPointer(2, this));
  }
  _disownOptions() {
    return $.utils.disown(this.options);
  }
  get options() {
    return $.utils.getStruct(2, HttpOptions, this);
  }
  _hasOptions() {
    return !$.utils.isNull($.utils.getPointer(2, this));
  }
  _initOptions() {
    return $.utils.initStructAt(2, HttpOptions, this);
  }
  set options(value) {
    $.utils.copyFrom(value, $.utils.getPointer(2, this));
  }
  _adoptTlsOptions(value) {
    $.utils.adopt(value, $.utils.getPointer(3, this));
  }
  _disownTlsOptions() {
    return $.utils.disown(this.tlsOptions);
  }
  get tlsOptions() {
    return $.utils.getStruct(3, TlsOptions, this);
  }
  _hasTlsOptions() {
    return !$.utils.isNull($.utils.getPointer(3, this));
  }
  _initTlsOptions() {
    return $.utils.initStructAt(3, TlsOptions, this);
  }
  set tlsOptions(value) {
    $.utils.copyFrom(value, $.utils.getPointer(3, this));
  }
  toString() {
    return "Socket_Https_" + super.toString();
  }
}
export const Socket_Which = {
  HTTP: 0,
  HTTPS: 1
};
export class Socket extends $.Struct {
  static HTTP = Socket_Which.HTTP;
  static HTTPS = Socket_Which.HTTPS;
  static _capnp = {
    displayName: "Socket",
    id: "9a0eba45530ee79f",
    size: new $.ObjectSize(8, 5)
  };
  /**
  * Each socket has a unique name which can be used on the command line to override the socket's
  * address with `--socket-addr <name>=<addr>` or `--socket-fd <name>=<fd>`.
  * */
  get name() {
    return $.utils.getText(0, this);
  }
  set name(value) {
    $.utils.setText(0, value, this);
  }
  /**
  * Address/port on which this socket will listen. Optional; if not specified, then you will be
  * required to specify the socket on the command line with with `--socket-addr <name>=<addr>` or
  * `--socket-fd <name>=<fd>`.
  *
  * Examples:
  * - "*:80": Listen on port 80 on all local IPv4 and IPv6 interfaces.
  * - "1.2.3.4": Listen on the specific IPv4 address on the default port for the protocol.
  * - "1.2.3.4:80": Listen on the specific IPv4 address and port.
  * - "1234:5678::abcd": Listen on the specific IPv6 address on the default port for the protocol.
  * - "[1234:5678::abcd]:80": Listen on the specific IPv6 address and port.
  * - "unix:/path/to/socket": Listen on a Unix socket.
  * - "unix-abstract:name": On Linux, listen on the given "abstract" Unix socket name.
  * - "example.com:80": Perform a DNS lookup to determine the address, and then listen on it. If
  *     this resolves to multiple addresses, listen on all of them.
  *
  * (These are the formats supported by KJ's parseAddress().)
  * */
  get address() {
    return $.utils.getText(1, this);
  }
  set address(value) {
    $.utils.setText(1, value, this);
  }
  _adoptHttp(value) {
    $.utils.setUint16(0, 0, this);
    $.utils.adopt(value, $.utils.getPointer(2, this));
  }
  _disownHttp() {
    return $.utils.disown(this.http);
  }
  get http() {
    $.utils.testWhich("http", $.utils.getUint16(0, this), 0, this);
    return $.utils.getStruct(2, HttpOptions, this);
  }
  _hasHttp() {
    return !$.utils.isNull($.utils.getPointer(2, this));
  }
  _initHttp() {
    $.utils.setUint16(0, 0, this);
    return $.utils.initStructAt(2, HttpOptions, this);
  }
  get _isHttp() {
    return $.utils.getUint16(0, this) === 0;
  }
  set http(value) {
    $.utils.setUint16(0, 0, this);
    $.utils.copyFrom(value, $.utils.getPointer(2, this));
  }
  get https() {
    $.utils.testWhich("https", $.utils.getUint16(0, this), 1, this);
    return $.utils.getAs(Socket_Https, this);
  }
  _initHttps() {
    $.utils.setUint16(0, 1, this);
    return $.utils.getAs(Socket_Https, this);
  }
  get _isHttps() {
    return $.utils.getUint16(0, this) === 1;
  }
  set https(_) {
    $.utils.setUint16(0, 1, this);
  }
  _adoptService(value) {
    $.utils.adopt(value, $.utils.getPointer(4, this));
  }
  _disownService() {
    return $.utils.disown(this.service);
  }
  /**
  * Service name which should handle requests on this socket.
  * */
  get service() {
    return $.utils.getStruct(4, ServiceDesignator, this);
  }
  _hasService() {
    return !$.utils.isNull($.utils.getPointer(4, this));
  }
  _initService() {
    return $.utils.initStructAt(4, ServiceDesignator, this);
  }
  set service(value) {
    $.utils.copyFrom(value, $.utils.getPointer(4, this));
  }
  toString() {
    return "Socket_" + super.toString();
  }
  which() {
    return $.utils.getUint16(0, this);
  }
}
export const Service_Which = {
  UNSPECIFIED: 0,
  WORKER: 1,
  NETWORK: 2,
  EXTERNAL: 3,
  DISK: 4
};
/**
* Defines a named service. Each server has a list of named services. The names are private,
* used to refer to the services within this same config file.
* */
export class Service extends $.Struct {
  static UNSPECIFIED = Service_Which.UNSPECIFIED;
  static WORKER = Service_Which.WORKER;
  static NETWORK = Service_Which.NETWORK;
  static EXTERNAL = Service_Which.EXTERNAL;
  static DISK = Service_Which.DISK;
  static _capnp = {
    displayName: "Service",
    id: "e5c88e8bb7bcb6b9",
    size: new $.ObjectSize(8, 2)
  };
  /**
  * Name of the service. Used only to refer to the service from elsewhere in the config file.
  * Services are not accessible unless you explicitly configure them to be, such as through a
  * `Socket` or through a binding from another Worker.
  * */
  get name() {
    return $.utils.getText(0, this);
  }
  set name(value) {
    $.utils.setText(0, value, this);
  }
  get _isUnspecified() {
    return $.utils.getUint16(0, this) === 0;
  }
  set unspecified(_) {
    $.utils.setUint16(0, 0, this);
  }
  _adoptWorker(value) {
    $.utils.setUint16(0, 1, this);
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownWorker() {
    return $.utils.disown(this.worker);
  }
  /**
  * A Worker!
  * */
  get worker() {
    $.utils.testWhich("worker", $.utils.getUint16(0, this), 1, this);
    return $.utils.getStruct(1, Worker, this);
  }
  _hasWorker() {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initWorker() {
    $.utils.setUint16(0, 1, this);
    return $.utils.initStructAt(1, Worker, this);
  }
  get _isWorker() {
    return $.utils.getUint16(0, this) === 1;
  }
  set worker(value) {
    $.utils.setUint16(0, 1, this);
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  _adoptNetwork(value) {
    $.utils.setUint16(0, 2, this);
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownNetwork() {
    return $.utils.disown(this.network);
  }
  /**
  * A service that implements access to a network. fetch() requests are routed according to
  * the URL hostname.
  * */
  get network() {
    $.utils.testWhich("network", $.utils.getUint16(0, this), 2, this);
    return $.utils.getStruct(1, Network, this);
  }
  _hasNetwork() {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initNetwork() {
    $.utils.setUint16(0, 2, this);
    return $.utils.initStructAt(1, Network, this);
  }
  get _isNetwork() {
    return $.utils.getUint16(0, this) === 2;
  }
  set network(value) {
    $.utils.setUint16(0, 2, this);
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  _adoptExternal(value) {
    $.utils.setUint16(0, 3, this);
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownExternal() {
    return $.utils.disown(this.external);
  }
  /**
  * A service that forwards all requests to a specific remote server. Typically used to
  * connect to a back-end server on your internal network.
  * */
  get external() {
    $.utils.testWhich("external", $.utils.getUint16(0, this), 3, this);
    return $.utils.getStruct(1, ExternalServer, this);
  }
  _hasExternal() {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initExternal() {
    $.utils.setUint16(0, 3, this);
    return $.utils.initStructAt(1, ExternalServer, this);
  }
  get _isExternal() {
    return $.utils.getUint16(0, this) === 3;
  }
  set external(value) {
    $.utils.setUint16(0, 3, this);
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  _adoptDisk(value) {
    $.utils.setUint16(0, 4, this);
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownDisk() {
    return $.utils.disown(this.disk);
  }
  /**
  * An HTTP service backed by a directory on disk, supporting a basic HTTP GET/PUT. Generally
  * not intended to be exposed directly to the internet; typically you want to bind this into
  * a Worker that adds logic for setting Content-Type and the like.
  * */
  get disk() {
    $.utils.testWhich("disk", $.utils.getUint16(0, this), 4, this);
    return $.utils.getStruct(1, DiskDirectory, this);
  }
  _hasDisk() {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initDisk() {
    $.utils.setUint16(0, 4, this);
    return $.utils.initStructAt(1, DiskDirectory, this);
  }
  get _isDisk() {
    return $.utils.getUint16(0, this) === 4;
  }
  set disk(value) {
    $.utils.setUint16(0, 4, this);
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  toString() {
    return "Service_" + super.toString();
  }
  which() {
    return $.utils.getUint16(0, this);
  }
}
/**
* A reference to a service from elsewhere in the config file, e.g. from a service binding in a
* Worker.
*
* In the case that only `name` needs to be specified, then you can provide a raw string wherever
* `ServiceDesignator` is needed. Cap'n proto automatically assumes the string is intended to be
* the value for `name`, since that is the first field. In other words, if you would otherwise
* write something like:
*
*     bindings = [(service = (name = "foo"))]
*
* You can write this instead, which is equivalent:
*
*     bindings = [(service = "foo")]
* */
export class ServiceDesignator extends $.Struct {
  static _capnp = {
    displayName: "ServiceDesignator",
    id: "ae8ec91cee724450",
    size: new $.ObjectSize(0, 2)
  };
  /**
  * Name of the service in the Config.services list.
  * */
  get name() {
    return $.utils.getText(0, this);
  }
  set name(value) {
    $.utils.setText(0, value, this);
  }
  /**
  * A modules-syntax Worker can export multiple named entrypoints. `export default {` specifies
  * the default entrypoint, whereas `export let foo = {` defines an entrypoint named `foo`. If
  * `entrypoint` is specified here, it names an alternate entrypoint to use on the target worker,
  * otherwise the default is used.
  * */
  get entrypoint() {
    return $.utils.getText(1, this);
  }
  set entrypoint(value) {
    $.utils.setText(1, value, this);
  }
  toString() {
    return "ServiceDesignator_" + super.toString();
  }
}
export const Worker_Module_Which = {
  ES_MODULE: 0,
  COMMON_JS_MODULE: 1,
  TEXT: 2,
  DATA: 3,
  WASM: 4,
  JSON: 5,
  NODE_JS_COMPAT_MODULE: 6,
  PYTHON_MODULE: 7,
  PYTHON_REQUIREMENT: 8
};
export class Worker_Module extends $.Struct {
  static ES_MODULE = Worker_Module_Which.ES_MODULE;
  static COMMON_JS_MODULE = Worker_Module_Which.COMMON_JS_MODULE;
  static TEXT = Worker_Module_Which.TEXT;
  static DATA = Worker_Module_Which.DATA;
  static WASM = Worker_Module_Which.WASM;
  static JSON = Worker_Module_Which.JSON;
  static NODE_JS_COMPAT_MODULE = Worker_Module_Which.NODE_JS_COMPAT_MODULE;
  static PYTHON_MODULE = Worker_Module_Which.PYTHON_MODULE;
  static PYTHON_REQUIREMENT = Worker_Module_Which.PYTHON_REQUIREMENT;
  static _capnp = {
    displayName: "Module",
    id: "d9d87a63770a12f3",
    size: new $.ObjectSize(8, 2)
  };
  /**
  * Name (or path) used to import the module.
  * */
  get name() {
    return $.utils.getText(0, this);
  }
  set name(value) {
    $.utils.setText(0, value, this);
  }
  /**
  * An ES module file with imports and exports.
  *
  * As with `serviceWorkerScript`, above, the value is the raw source code.
  * */
  get esModule() {
    $.utils.testWhich("esModule", $.utils.getUint16(0, this), 0, this);
    return $.utils.getText(1, this);
  }
  get _isEsModule() {
    return $.utils.getUint16(0, this) === 0;
  }
  set esModule(value) {
    $.utils.setUint16(0, 0, this);
    $.utils.setText(1, value, this);
  }
  /**
  * A common JS module, using require().
  * */
  get commonJsModule() {
    $.utils.testWhich("commonJsModule", $.utils.getUint16(0, this), 1, this);
    return $.utils.getText(1, this);
  }
  get _isCommonJsModule() {
    return $.utils.getUint16(0, this) === 1;
  }
  set commonJsModule(value) {
    $.utils.setUint16(0, 1, this);
    $.utils.setText(1, value, this);
  }
  /**
  * A raw text blob. Importing this will produce a string with the value.
  * */
  get text() {
    $.utils.testWhich("text", $.utils.getUint16(0, this), 2, this);
    return $.utils.getText(1, this);
  }
  get _isText() {
    return $.utils.getUint16(0, this) === 2;
  }
  set text(value) {
    $.utils.setUint16(0, 2, this);
    $.utils.setText(1, value, this);
  }
  _adoptData(value) {
    $.utils.setUint16(0, 3, this);
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownData() {
    return $.utils.disown(this.data);
  }
  /**
  * A raw data blob. Importing this will produce an ArrayBuffer with the value.
  * */
  get data() {
    $.utils.testWhich("data", $.utils.getUint16(0, this), 3, this);
    return $.utils.getData(1, this);
  }
  _hasData() {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initData(length) {
    $.utils.setUint16(0, 3, this);
    return $.utils.initData(1, length, this);
  }
  get _isData() {
    return $.utils.getUint16(0, this) === 3;
  }
  set data(value) {
    $.utils.setUint16(0, 3, this);
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  _adoptWasm(value) {
    $.utils.setUint16(0, 4, this);
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownWasm() {
    return $.utils.disown(this.wasm);
  }
  /**
  * A Wasm module. The value is a compiled binary Wasm module file. Importing this will produce
  * a `WebAssembly.Module` object, which you can then instantiate.
  * */
  get wasm() {
    $.utils.testWhich("wasm", $.utils.getUint16(0, this), 4, this);
    return $.utils.getData(1, this);
  }
  _hasWasm() {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initWasm(length) {
    $.utils.setUint16(0, 4, this);
    return $.utils.initData(1, length, this);
  }
  get _isWasm() {
    return $.utils.getUint16(0, this) === 4;
  }
  set wasm(value) {
    $.utils.setUint16(0, 4, this);
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  /**
  * Importing this will produce the result of parsing the given text as JSON.
  * */
  get json() {
    $.utils.testWhich("json", $.utils.getUint16(0, this), 5, this);
    return $.utils.getText(1, this);
  }
  get _isJson() {
    return $.utils.getUint16(0, this) === 5;
  }
  set json(value) {
    $.utils.setUint16(0, 5, this);
    $.utils.setText(1, value, this);
  }
  /**
  * A Node.js module is a specialization of a commonJsModule that:
  * (a) allows for importing Node.js-compat built-ins without the node: specifier-prefix
  * (b) exposes the subset of common Node.js globals such as process, Buffer, etc that
  *     we implement in the workerd runtime.
  * */
  get nodeJsCompatModule() {
    $.utils.testWhich("nodeJsCompatModule", $.utils.getUint16(0, this), 6, this);
    return $.utils.getText(1, this);
  }
  get _isNodeJsCompatModule() {
    return $.utils.getUint16(0, this) === 6;
  }
  set nodeJsCompatModule(value) {
    $.utils.setUint16(0, 6, this);
    $.utils.setText(1, value, this);
  }
  /**
  * A Python module. All bundles containing this value type are converted into a JS/WASM Worker
  * Bundle prior to execution.
  * */
  get pythonModule() {
    $.utils.testWhich("pythonModule", $.utils.getUint16(0, this), 7, this);
    return $.utils.getText(1, this);
  }
  get _isPythonModule() {
    return $.utils.getUint16(0, this) === 7;
  }
  set pythonModule(value) {
    $.utils.setUint16(0, 7, this);
    $.utils.setText(1, value, this);
  }
  /**
  * A Python package that is required by this bundle. The package must be supported by
  * Pyodide (https://pyodide.org/en/stable/usage/packages-in-pyodide.html). All packages listed
  * will be installed prior to the execution of the worker.
  * */
  get pythonRequirement() {
    $.utils.testWhich("pythonRequirement", $.utils.getUint16(0, this), 8, this);
    return $.utils.getText(1, this);
  }
  get _isPythonRequirement() {
    return $.utils.getUint16(0, this) === 8;
  }
  set pythonRequirement(value) {
    $.utils.setUint16(0, 8, this);
    $.utils.setText(1, value, this);
  }
  toString() {
    return "Worker_Module_" + super.toString();
  }
  which() {
    return $.utils.getUint16(0, this);
  }
}
export const Worker_Binding_Type_Which = {
  UNSPECIFIED: 0,
  TEXT: 1,
  DATA: 2,
  JSON: 3,
  WASM: 4,
  CRYPTO_KEY: 5,
  SERVICE: 6,
  DURABLE_OBJECT_NAMESPACE: 7,
  KV_NAMESPACE: 8,
  R2BUCKET: 9,
  R2ADMIN: 10,
  QUEUE: 11,
  ANALYTICS_ENGINE: 12,
  HYPERDRIVE: 13
};
/**
* Specifies the type of a parameter binding.
* */
export class Worker_Binding_Type extends $.Struct {
  static UNSPECIFIED = Worker_Binding_Type_Which.UNSPECIFIED;
  static TEXT = Worker_Binding_Type_Which.TEXT;
  static DATA = Worker_Binding_Type_Which.DATA;
  static JSON = Worker_Binding_Type_Which.JSON;
  static WASM = Worker_Binding_Type_Which.WASM;
  static CRYPTO_KEY = Worker_Binding_Type_Which.CRYPTO_KEY;
  static SERVICE = Worker_Binding_Type_Which.SERVICE;
  static DURABLE_OBJECT_NAMESPACE = Worker_Binding_Type_Which.DURABLE_OBJECT_NAMESPACE;
  static KV_NAMESPACE = Worker_Binding_Type_Which.KV_NAMESPACE;
  static R2BUCKET = Worker_Binding_Type_Which.R2BUCKET;
  static R2ADMIN = Worker_Binding_Type_Which.R2ADMIN;
  static QUEUE = Worker_Binding_Type_Which.QUEUE;
  static ANALYTICS_ENGINE = Worker_Binding_Type_Which.ANALYTICS_ENGINE;
  static HYPERDRIVE = Worker_Binding_Type_Which.HYPERDRIVE;
  static _capnp = {
    displayName: "Type",
    id: "8906a1296519bf8a",
    size: new $.ObjectSize(8, 1)
  };
  get _isUnspecified() {
    return $.utils.getUint16(0, this) === 0;
  }
  set unspecified(_) {
    $.utils.setUint16(0, 0, this);
  }
  get _isText() {
    return $.utils.getUint16(0, this) === 1;
  }
  set text(_) {
    $.utils.setUint16(0, 1, this);
  }
  get _isData() {
    return $.utils.getUint16(0, this) === 2;
  }
  set data(_) {
    $.utils.setUint16(0, 2, this);
  }
  get _isJson() {
    return $.utils.getUint16(0, this) === 3;
  }
  set json(_) {
    $.utils.setUint16(0, 3, this);
  }
  get _isWasm() {
    return $.utils.getUint16(0, this) === 4;
  }
  set wasm(_) {
    $.utils.setUint16(0, 4, this);
  }
  _adoptCryptoKey(value) {
    $.utils.setUint16(0, 5, this);
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownCryptoKey() {
    return $.utils.disown(this.cryptoKey);
  }
  get cryptoKey() {
    $.utils.testWhich("cryptoKey", $.utils.getUint16(0, this), 5, this);
    return $.utils.getList(0, $.Uint16List, this);
  }
  _hasCryptoKey() {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initCryptoKey(length) {
    $.utils.setUint16(0, 5, this);
    return $.utils.initList(0, $.Uint16List, length, this);
  }
  get _isCryptoKey() {
    return $.utils.getUint16(0, this) === 5;
  }
  set cryptoKey(value) {
    $.utils.setUint16(0, 5, this);
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  get _isService() {
    return $.utils.getUint16(0, this) === 6;
  }
  set service(_) {
    $.utils.setUint16(0, 6, this);
  }
  get _isDurableObjectNamespace() {
    return $.utils.getUint16(0, this) === 7;
  }
  set durableObjectNamespace(_) {
    $.utils.setUint16(0, 7, this);
  }
  get _isKvNamespace() {
    return $.utils.getUint16(0, this) === 8;
  }
  set kvNamespace(_) {
    $.utils.setUint16(0, 8, this);
  }
  get _isR2Bucket() {
    return $.utils.getUint16(0, this) === 9;
  }
  set r2Bucket(_) {
    $.utils.setUint16(0, 9, this);
  }
  get _isR2Admin() {
    return $.utils.getUint16(0, this) === 10;
  }
  set r2Admin(_) {
    $.utils.setUint16(0, 10, this);
  }
  get _isQueue() {
    return $.utils.getUint16(0, this) === 11;
  }
  set queue(_) {
    $.utils.setUint16(0, 11, this);
  }
  get _isAnalyticsEngine() {
    return $.utils.getUint16(0, this) === 12;
  }
  set analyticsEngine(_) {
    $.utils.setUint16(0, 12, this);
  }
  get _isHyperdrive() {
    return $.utils.getUint16(0, this) === 13;
  }
  set hyperdrive(_) {
    $.utils.setUint16(0, 13, this);
  }
  toString() {
    return "Worker_Binding_Type_" + super.toString();
  }
  which() {
    return $.utils.getUint16(0, this);
  }
}
/**
* The type of a Durable Object namespace binding.
* */
export class Worker_Binding_DurableObjectNamespaceDesignator extends $.Struct {
  static _capnp = {
    displayName: "DurableObjectNamespaceDesignator",
    id: "804f144ff477aac7",
    size: new $.ObjectSize(0, 2)
  };
  /**
  * Exported class name that implements the Durable Object.
  * */
  get className() {
    return $.utils.getText(0, this);
  }
  set className(value) {
    $.utils.setText(0, value, this);
  }
  /**
  * The service name of the worker that defines this class. If omitted, the current worker
  * is assumed.
  *
  * Use of this field is discouraged. Instead, when accessing a different Worker's Durable
  * Objects, specify a `service` binding to that worker, and have the worker implement an
  * appropriate API.
  *
  * (This is intentionally not a ServiceDesignator because you cannot choose an alternate
  * entrypoint here; the class name IS the entrypoint.)
  * */
  get serviceName() {
    return $.utils.getText(1, this);
  }
  set serviceName(value) {
    $.utils.setText(1, value, this);
  }
  toString() {
    return "Worker_Binding_DurableObjectNamespaceDesignator_" + super.toString();
  }
}
export const Worker_Binding_CryptoKey_Usage = {
  ENCRYPT: 0,
  DECRYPT: 1,
  SIGN: 2,
  VERIFY: 3,
  DERIVE_KEY: 4,
  DERIVE_BITS: 5,
  WRAP_KEY: 6,
  UNWRAP_KEY: 7
};
export const Worker_Binding_CryptoKey_Algorithm_Which = {
  NAME: 0,
  JSON: 1
};
/**
* Value for the `algorithm` parameter.
* */
export class Worker_Binding_CryptoKey_Algorithm extends $.Struct {
  static NAME = Worker_Binding_CryptoKey_Algorithm_Which.NAME;
  static JSON = Worker_Binding_CryptoKey_Algorithm_Which.JSON;
  static _capnp = {
    displayName: "algorithm",
    id: "a1a040c5e00d7021",
    size: new $.ObjectSize(8, 3)
  };
  /**
  * Just a name, like `AES-GCM`.
  * */
  get name() {
    $.utils.testWhich("name", $.utils.getUint16(2, this), 0, this);
    return $.utils.getText(1, this);
  }
  get _isName() {
    return $.utils.getUint16(2, this) === 0;
  }
  set name(value) {
    $.utils.setUint16(2, 0, this);
    $.utils.setText(1, value, this);
  }
  /**
  * An object, encoded here as JSON.
  * */
  get json() {
    $.utils.testWhich("json", $.utils.getUint16(2, this), 1, this);
    return $.utils.getText(1, this);
  }
  get _isJson() {
    return $.utils.getUint16(2, this) === 1;
  }
  set json(value) {
    $.utils.setUint16(2, 1, this);
    $.utils.setText(1, value, this);
  }
  toString() {
    return "Worker_Binding_CryptoKey_Algorithm_" + super.toString();
  }
  which() {
    return $.utils.getUint16(2, this);
  }
}
export const Worker_Binding_CryptoKey_Which = {
  RAW: 0,
  HEX: 1,
  BASE64: 2,
  PKCS8: 3,
  SPKI: 4,
  JWK: 5
};
/**
* Parameters to crypto.subtle.importKey().
* */
export class Worker_Binding_CryptoKey extends $.Struct {
  static RAW = Worker_Binding_CryptoKey_Which.RAW;
  static HEX = Worker_Binding_CryptoKey_Which.HEX;
  static BASE64 = Worker_Binding_CryptoKey_Which.BASE64;
  static PKCS8 = Worker_Binding_CryptoKey_Which.PKCS8;
  static SPKI = Worker_Binding_CryptoKey_Which.SPKI;
  static JWK = Worker_Binding_CryptoKey_Which.JWK;
  static Usage = Worker_Binding_CryptoKey_Usage;
  static _capnp = {
    displayName: "CryptoKey",
    id: "b5e1bff0e57d6eb0",
    size: new $.ObjectSize(8, 3),
    defaultExtractable: $.getBitMask(false, 0)
  };
  _adoptRaw(value) {
    $.utils.setUint16(0, 0, this);
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownRaw() {
    return $.utils.disown(this.raw);
  }
  get raw() {
    $.utils.testWhich("raw", $.utils.getUint16(0, this), 0, this);
    return $.utils.getData(0, this);
  }
  _hasRaw() {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initRaw(length) {
    $.utils.setUint16(0, 0, this);
    return $.utils.initData(0, length, this);
  }
  get _isRaw() {
    return $.utils.getUint16(0, this) === 0;
  }
  set raw(value) {
    $.utils.setUint16(0, 0, this);
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  get hex() {
    $.utils.testWhich("hex", $.utils.getUint16(0, this), 1, this);
    return $.utils.getText(0, this);
  }
  get _isHex() {
    return $.utils.getUint16(0, this) === 1;
  }
  set hex(value) {
    $.utils.setUint16(0, 1, this);
    $.utils.setText(0, value, this);
  }
  /**
  * Raw key material, possibly hex or base64-encoded. Use this for symmetric keys.
  *
  * Hint: `raw` would typically be used with Cap'n Proto's `embed` syntax to embed an
  * external binary key file. `hex` or `base64` could do that too but can also be specified
  * inline.
  * */
  get base64() {
    $.utils.testWhich("base64", $.utils.getUint16(0, this), 2, this);
    return $.utils.getText(0, this);
  }
  get _isBase64() {
    return $.utils.getUint16(0, this) === 2;
  }
  set base64(value) {
    $.utils.setUint16(0, 2, this);
    $.utils.setText(0, value, this);
  }
  /**
  * Private key in PEM-encoded PKCS#8 format.
  * */
  get pkcs8() {
    $.utils.testWhich("pkcs8", $.utils.getUint16(0, this), 3, this);
    return $.utils.getText(0, this);
  }
  get _isPkcs8() {
    return $.utils.getUint16(0, this) === 3;
  }
  set pkcs8(value) {
    $.utils.setUint16(0, 3, this);
    $.utils.setText(0, value, this);
  }
  /**
  * Public key in PEM-encoded SPKI format.
  * */
  get spki() {
    $.utils.testWhich("spki", $.utils.getUint16(0, this), 4, this);
    return $.utils.getText(0, this);
  }
  get _isSpki() {
    return $.utils.getUint16(0, this) === 4;
  }
  set spki(value) {
    $.utils.setUint16(0, 4, this);
    $.utils.setText(0, value, this);
  }
  /**
  * Key in JSON format.
  * */
  get jwk() {
    $.utils.testWhich("jwk", $.utils.getUint16(0, this), 5, this);
    return $.utils.getText(0, this);
  }
  get _isJwk() {
    return $.utils.getUint16(0, this) === 5;
  }
  set jwk(value) {
    $.utils.setUint16(0, 5, this);
    $.utils.setText(0, value, this);
  }
  /**
  * Value for the `algorithm` parameter.
  * */
  get algorithm() {
    return $.utils.getAs(Worker_Binding_CryptoKey_Algorithm, this);
  }
  _initAlgorithm() {
    return $.utils.getAs(Worker_Binding_CryptoKey_Algorithm, this);
  }
  /**
  * Is the Worker allowed to export this key to obtain the underlying key material? Setting
  * this false ensures that the key cannot be leaked by errant JavaScript code; the key can
  * only be used in WebCrypto operations.
  * */
  get extractable() {
    return $.utils.getBit(32, this, Worker_Binding_CryptoKey._capnp.defaultExtractable);
  }
  set extractable(value) {
    $.utils.setBit(32, value, this, Worker_Binding_CryptoKey._capnp.defaultExtractable);
  }
  _adoptUsages(value) {
    $.utils.adopt(value, $.utils.getPointer(2, this));
  }
  _disownUsages() {
    return $.utils.disown(this.usages);
  }
  /**
  * What operations is this key permitted to be used for?
  * */
  get usages() {
    return $.utils.getList(2, $.Uint16List, this);
  }
  _hasUsages() {
    return !$.utils.isNull($.utils.getPointer(2, this));
  }
  _initUsages(length) {
    return $.utils.initList(2, $.Uint16List, length, this);
  }
  set usages(value) {
    $.utils.copyFrom(value, $.utils.getPointer(2, this));
  }
  toString() {
    return "Worker_Binding_CryptoKey_" + super.toString();
  }
  which() {
    return $.utils.getUint16(0, this);
  }
}
export class Worker_Binding_MemoryCacheLimits extends $.Struct {
  static _capnp = {
    displayName: "MemoryCacheLimits",
    id: "8d66725b0867e634",
    size: new $.ObjectSize(16, 0)
  };
  get maxKeys() {
    return $.utils.getUint32(0, this);
  }
  set maxKeys(value) {
    $.utils.setUint32(0, value, this);
  }
  get maxValueSize() {
    return $.utils.getUint32(4, this);
  }
  set maxValueSize(value) {
    $.utils.setUint32(4, value, this);
  }
  get maxTotalValueSize() {
    return $.utils.getUint64(8, this);
  }
  set maxTotalValueSize(value) {
    $.utils.setUint64(8, value, this);
  }
  toString() {
    return "Worker_Binding_MemoryCacheLimits_" + super.toString();
  }
}
/**
* A binding that wraps a group of (lower-level) bindings in a common API.
* */
export class Worker_Binding_WrappedBinding extends $.Struct {
  static _capnp = {
    displayName: "WrappedBinding",
    id: "e6f066b75f0ea113",
    size: new $.ObjectSize(0, 3),
    defaultEntrypoint: "default"
  };
  static _InnerBindings;
  /**
  * Wrapper module name.
  * The module must be an internal one (provided by extension or registered in the c++ code).
  * Module will be instantitated during binding initialization phase.
  * */
  get moduleName() {
    return $.utils.getText(0, this);
  }
  set moduleName(value) {
    $.utils.setText(0, value, this);
  }
  /**
  * Module needs to export a function with a given name (default export gets "default" name).
  * The function needs to accept a single `env` argument - a dictionary with inner bindings.
  * Function will be invoked during initialization phase and its return value will be used as
  * resulting binding value.
  * */
  get entrypoint() {
    return $.utils.getText(1, this, Worker_Binding_WrappedBinding._capnp.defaultEntrypoint);
  }
  set entrypoint(value) {
    $.utils.setText(1, value, this);
  }
  _adoptInnerBindings(value) {
    $.utils.adopt(value, $.utils.getPointer(2, this));
  }
  _disownInnerBindings() {
    return $.utils.disown(this.innerBindings);
  }
  /**
  * Inner bindings that will be created and passed in the env dictionary.
  * These bindings shall be used to implement end-user api, and are not available to the
  * binding consumers unless "re-exported" in wrapBindings function.
  * */
  get innerBindings() {
    return $.utils.getList(2, Worker_Binding_WrappedBinding._InnerBindings, this);
  }
  _hasInnerBindings() {
    return !$.utils.isNull($.utils.getPointer(2, this));
  }
  _initInnerBindings(length) {
    return $.utils.initList(2, Worker_Binding_WrappedBinding._InnerBindings, length, this);
  }
  set innerBindings(value) {
    $.utils.copyFrom(value, $.utils.getPointer(2, this));
  }
  toString() {
    return "Worker_Binding_WrappedBinding_" + super.toString();
  }
}
/**
* Indicates that the Worker requires a binding of the given type, but it won't be specified
* here. Another Worker can inherit this Worker and fill in this binding.
* */
export class Worker_Binding_Parameter extends $.Struct {
  static _capnp = {
    displayName: "parameter",
    id: "dc57e1258d26d152",
    size: new $.ObjectSize(8, 6)
  };
  _adoptType(value) {
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownType() {
    return $.utils.disown(this.type);
  }
  /**
  * Expected type of this parameter.
  * */
  get type() {
    return $.utils.getStruct(1, Worker_Binding_Type, this);
  }
  _hasType() {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initType() {
    return $.utils.initStructAt(1, Worker_Binding_Type, this);
  }
  set type(value) {
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  /**
  * If true, this binding is optional. Derived workers need not specify it, in which case
  * the binding won't be present in the environment object passed to the worker.
  *
  * When a Worker has any non-optional parameters that haven't been filled in, then it can
  * only be used for inheritance; it cannot be invoked directly.
  * */
  get optional() {
    return $.utils.getBit(16, this);
  }
  set optional(value) {
    $.utils.setBit(16, value, this);
  }
  toString() {
    return "Worker_Binding_Parameter_" + super.toString();
  }
}
/**
* A binding for Hyperdrive. Allows workers to use Hyperdrive caching & pooling for Postgres
* databases.
* */
export class Worker_Binding_Hyperdrive extends $.Struct {
  static _capnp = {
    displayName: "hyperdrive",
    id: "ad6c391cd55f3134",
    size: new $.ObjectSize(8, 6)
  };
  _adoptDesignator(value) {
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownDesignator() {
    return $.utils.disown(this.designator);
  }
  get designator() {
    return $.utils.getStruct(1, ServiceDesignator, this);
  }
  _hasDesignator() {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initDesignator() {
    return $.utils.initStructAt(1, ServiceDesignator, this);
  }
  set designator(value) {
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  get database() {
    return $.utils.getText(2, this);
  }
  set database(value) {
    $.utils.setText(2, value, this);
  }
  get user() {
    return $.utils.getText(3, this);
  }
  set user(value) {
    $.utils.setText(3, value, this);
  }
  get password() {
    return $.utils.getText(4, this);
  }
  set password(value) {
    $.utils.setText(4, value, this);
  }
  get scheme() {
    return $.utils.getText(5, this);
  }
  set scheme(value) {
    $.utils.setText(5, value, this);
  }
  toString() {
    return "Worker_Binding_Hyperdrive_" + super.toString();
  }
}
/**
* A binding representing access to an in-memory cache.
* */
export class Worker_Binding_MemoryCache extends $.Struct {
  static _capnp = {
    displayName: "memoryCache",
    id: "aed5760c349869da",
    size: new $.ObjectSize(8, 6)
  };
  /**
  * The identifier associated with this cache. Any number of isolates
  * can access the same in-memory cache (within the same process), and
  * each worker may use any number of in-memory caches.
  * */
  get id() {
    return $.utils.getText(1, this);
  }
  set id(value) {
    $.utils.setText(1, value, this);
  }
  _adoptLimits(value) {
    $.utils.adopt(value, $.utils.getPointer(2, this));
  }
  _disownLimits() {
    return $.utils.disown(this.limits);
  }
  get limits() {
    return $.utils.getStruct(2, Worker_Binding_MemoryCacheLimits, this);
  }
  _hasLimits() {
    return !$.utils.isNull($.utils.getPointer(2, this));
  }
  _initLimits() {
    return $.utils.initStructAt(2, Worker_Binding_MemoryCacheLimits, this);
  }
  set limits(value) {
    $.utils.copyFrom(value, $.utils.getPointer(2, this));
  }
  toString() {
    return "Worker_Binding_MemoryCache_" + super.toString();
  }
}
export const Worker_Binding_Which = {
  UNSPECIFIED: 0,
  PARAMETER: 1,
  TEXT: 2,
  DATA: 3,
  JSON: 4,
  WASM_MODULE: 5,
  CRYPTO_KEY: 6,
  SERVICE: 7,
  DURABLE_OBJECT_NAMESPACE: 8,
  KV_NAMESPACE: 9,
  R2BUCKET: 10,
  R2ADMIN: 11,
  WRAPPED: 12,
  QUEUE: 13,
  FROM_ENVIRONMENT: 14,
  ANALYTICS_ENGINE: 15,
  HYPERDRIVE: 16,
  UNSAFE_EVAL: 17,
  MEMORY_CACHE: 18
};
export class Worker_Binding extends $.Struct {
  static UNSPECIFIED = Worker_Binding_Which.UNSPECIFIED;
  static PARAMETER = Worker_Binding_Which.PARAMETER;
  static TEXT = Worker_Binding_Which.TEXT;
  static DATA = Worker_Binding_Which.DATA;
  static JSON = Worker_Binding_Which.JSON;
  static WASM_MODULE = Worker_Binding_Which.WASM_MODULE;
  static CRYPTO_KEY = Worker_Binding_Which.CRYPTO_KEY;
  static SERVICE = Worker_Binding_Which.SERVICE;
  static DURABLE_OBJECT_NAMESPACE = Worker_Binding_Which.DURABLE_OBJECT_NAMESPACE;
  static KV_NAMESPACE = Worker_Binding_Which.KV_NAMESPACE;
  static R2BUCKET = Worker_Binding_Which.R2BUCKET;
  static R2ADMIN = Worker_Binding_Which.R2ADMIN;
  static WRAPPED = Worker_Binding_Which.WRAPPED;
  static QUEUE = Worker_Binding_Which.QUEUE;
  static FROM_ENVIRONMENT = Worker_Binding_Which.FROM_ENVIRONMENT;
  static ANALYTICS_ENGINE = Worker_Binding_Which.ANALYTICS_ENGINE;
  static HYPERDRIVE = Worker_Binding_Which.HYPERDRIVE;
  static UNSAFE_EVAL = Worker_Binding_Which.UNSAFE_EVAL;
  static MEMORY_CACHE = Worker_Binding_Which.MEMORY_CACHE;
  static Type = Worker_Binding_Type;
  static DurableObjectNamespaceDesignator = Worker_Binding_DurableObjectNamespaceDesignator;
  static CryptoKey = Worker_Binding_CryptoKey;
  static MemoryCacheLimits = Worker_Binding_MemoryCacheLimits;
  static WrappedBinding = Worker_Binding_WrappedBinding;
  static _capnp = {
    displayName: "Binding",
    id: "8e7e492fd7e35f3e",
    size: new $.ObjectSize(8, 6)
  };
  get name() {
    return $.utils.getText(0, this);
  }
  set name(value) {
    $.utils.setText(0, value, this);
  }
  get _isUnspecified() {
    return $.utils.getUint16(0, this) === 0;
  }
  set unspecified(_) {
    $.utils.setUint16(0, 0, this);
  }
  /**
  * Indicates that the Worker requires a binding of the given type, but it won't be specified
  * here. Another Worker can inherit this Worker and fill in this binding.
  * */
  get parameter() {
    $.utils.testWhich("parameter", $.utils.getUint16(0, this), 1, this);
    return $.utils.getAs(Worker_Binding_Parameter, this);
  }
  _initParameter() {
    $.utils.setUint16(0, 1, this);
    return $.utils.getAs(Worker_Binding_Parameter, this);
  }
  get _isParameter() {
    return $.utils.getUint16(0, this) === 1;
  }
  set parameter(_) {
    $.utils.setUint16(0, 1, this);
  }
  /**
  * A string.
  * */
  get text() {
    $.utils.testWhich("text", $.utils.getUint16(0, this), 2, this);
    return $.utils.getText(1, this);
  }
  get _isText() {
    return $.utils.getUint16(0, this) === 2;
  }
  set text(value) {
    $.utils.setUint16(0, 2, this);
    $.utils.setText(1, value, this);
  }
  _adoptData(value) {
    $.utils.setUint16(0, 3, this);
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownData() {
    return $.utils.disown(this.data);
  }
  /**
  * An ArrayBuffer.
  * */
  get data() {
    $.utils.testWhich("data", $.utils.getUint16(0, this), 3, this);
    return $.utils.getData(1, this);
  }
  _hasData() {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initData(length) {
    $.utils.setUint16(0, 3, this);
    return $.utils.initData(1, length, this);
  }
  get _isData() {
    return $.utils.getUint16(0, this) === 3;
  }
  set data(value) {
    $.utils.setUint16(0, 3, this);
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  /**
  * A value parsed from JSON.
  * */
  get json() {
    $.utils.testWhich("json", $.utils.getUint16(0, this), 4, this);
    return $.utils.getText(1, this);
  }
  get _isJson() {
    return $.utils.getUint16(0, this) === 4;
  }
  set json(value) {
    $.utils.setUint16(0, 4, this);
    $.utils.setText(1, value, this);
  }
  _adoptWasmModule(value) {
    $.utils.setUint16(0, 5, this);
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownWasmModule() {
    return $.utils.disown(this.wasmModule);
  }
  /**
  * A WebAssembly module. The binding will be an instance of `WebAssembly.Module`. Only
  * supported when using Service Workers syntax.
  *
  * DEPRECATED: Please switch to ES modules syntax instead, and embed Wasm modules as modules.
  * */
  get wasmModule() {
    $.utils.testWhich("wasmModule", $.utils.getUint16(0, this), 5, this);
    return $.utils.getData(1, this);
  }
  _hasWasmModule() {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initWasmModule(length) {
    $.utils.setUint16(0, 5, this);
    return $.utils.initData(1, length, this);
  }
  get _isWasmModule() {
    return $.utils.getUint16(0, this) === 5;
  }
  set wasmModule(value) {
    $.utils.setUint16(0, 5, this);
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  _adoptCryptoKey(value) {
    $.utils.setUint16(0, 6, this);
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownCryptoKey() {
    return $.utils.disown(this.cryptoKey);
  }
  /**
  * A CryptoKey instance, for use with the WebCrypto API.
  *
  * Note that by setting `extractable = false`, you can prevent the Worker code from accessing
  * or leaking the raw key material; it will only be able to use the key to perform WebCrypto
  * operations.
  * */
  get cryptoKey() {
    $.utils.testWhich("cryptoKey", $.utils.getUint16(0, this), 6, this);
    return $.utils.getStruct(1, Worker_Binding_CryptoKey, this);
  }
  _hasCryptoKey() {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initCryptoKey() {
    $.utils.setUint16(0, 6, this);
    return $.utils.initStructAt(1, Worker_Binding_CryptoKey, this);
  }
  get _isCryptoKey() {
    return $.utils.getUint16(0, this) === 6;
  }
  set cryptoKey(value) {
    $.utils.setUint16(0, 6, this);
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  _adoptService(value) {
    $.utils.setUint16(0, 7, this);
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownService() {
    return $.utils.disown(this.service);
  }
  /**
  * Binding to a named service (possibly, a worker).
  * */
  get service() {
    $.utils.testWhich("service", $.utils.getUint16(0, this), 7, this);
    return $.utils.getStruct(1, ServiceDesignator, this);
  }
  _hasService() {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initService() {
    $.utils.setUint16(0, 7, this);
    return $.utils.initStructAt(1, ServiceDesignator, this);
  }
  get _isService() {
    return $.utils.getUint16(0, this) === 7;
  }
  set service(value) {
    $.utils.setUint16(0, 7, this);
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  _adoptDurableObjectNamespace(value) {
    $.utils.setUint16(0, 8, this);
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownDurableObjectNamespace() {
    return $.utils.disown(this.durableObjectNamespace);
  }
  /**
  * Binding to the durable object namespace implemented by the given class.
  *
  * In the common case that this refers to a class in the same Worker, you can specify just
  * a string, like:
  *
  *     durableObjectNamespace = "MyClass"
  * */
  get durableObjectNamespace() {
    $.utils.testWhich("durableObjectNamespace", $.utils.getUint16(0, this), 8, this);
    return $.utils.getStruct(1, Worker_Binding_DurableObjectNamespaceDesignator, this);
  }
  _hasDurableObjectNamespace() {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initDurableObjectNamespace() {
    $.utils.setUint16(0, 8, this);
    return $.utils.initStructAt(1, Worker_Binding_DurableObjectNamespaceDesignator, this);
  }
  get _isDurableObjectNamespace() {
    return $.utils.getUint16(0, this) === 8;
  }
  set durableObjectNamespace(value) {
    $.utils.setUint16(0, 8, this);
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  _adoptKvNamespace(value) {
    $.utils.setUint16(0, 9, this);
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownKvNamespace() {
    return $.utils.disown(this.kvNamespace);
  }
  /**
  * A KV namespace, implemented by the named service. The Worker sees a KvNamespace-typed
  * binding. Requests to the namespace will be converted into HTTP requests targetting the
  * given service name.
  * */
  get kvNamespace() {
    $.utils.testWhich("kvNamespace", $.utils.getUint16(0, this), 9, this);
    return $.utils.getStruct(1, ServiceDesignator, this);
  }
  _hasKvNamespace() {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initKvNamespace() {
    $.utils.setUint16(0, 9, this);
    return $.utils.initStructAt(1, ServiceDesignator, this);
  }
  get _isKvNamespace() {
    return $.utils.getUint16(0, this) === 9;
  }
  set kvNamespace(value) {
    $.utils.setUint16(0, 9, this);
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  _adoptR2Bucket(value) {
    $.utils.setUint16(0, 10, this);
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownR2Bucket() {
    return $.utils.disown(this.r2Bucket);
  }
  get r2Bucket() {
    $.utils.testWhich("r2Bucket", $.utils.getUint16(0, this), 10, this);
    return $.utils.getStruct(1, ServiceDesignator, this);
  }
  _hasR2Bucket() {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initR2Bucket() {
    $.utils.setUint16(0, 10, this);
    return $.utils.initStructAt(1, ServiceDesignator, this);
  }
  get _isR2Bucket() {
    return $.utils.getUint16(0, this) === 10;
  }
  set r2Bucket(value) {
    $.utils.setUint16(0, 10, this);
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  _adoptR2Admin(value) {
    $.utils.setUint16(0, 11, this);
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownR2Admin() {
    return $.utils.disown(this.r2Admin);
  }
  /**
  * R2 bucket and admin API bindings. Similar to KV namespaces, these turn operations into
  * HTTP requests aimed at the named service.
  * */
  get r2Admin() {
    $.utils.testWhich("r2Admin", $.utils.getUint16(0, this), 11, this);
    return $.utils.getStruct(1, ServiceDesignator, this);
  }
  _hasR2Admin() {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initR2Admin() {
    $.utils.setUint16(0, 11, this);
    return $.utils.initStructAt(1, ServiceDesignator, this);
  }
  get _isR2Admin() {
    return $.utils.getUint16(0, this) === 11;
  }
  set r2Admin(value) {
    $.utils.setUint16(0, 11, this);
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  _adoptWrapped(value) {
    $.utils.setUint16(0, 12, this);
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownWrapped() {
    return $.utils.disown(this.wrapped);
  }
  /**
  * Wraps a collection of inner bindings in a common api functionality.
  * */
  get wrapped() {
    $.utils.testWhich("wrapped", $.utils.getUint16(0, this), 12, this);
    return $.utils.getStruct(1, Worker_Binding_WrappedBinding, this);
  }
  _hasWrapped() {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initWrapped() {
    $.utils.setUint16(0, 12, this);
    return $.utils.initStructAt(1, Worker_Binding_WrappedBinding, this);
  }
  get _isWrapped() {
    return $.utils.getUint16(0, this) === 12;
  }
  set wrapped(value) {
    $.utils.setUint16(0, 12, this);
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  _adoptQueue(value) {
    $.utils.setUint16(0, 13, this);
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownQueue() {
    return $.utils.disown(this.queue);
  }
  /**
  * A Queue binding, implemented by the named service. Requests to the
  * namespace will be converted into HTTP requests targetting the given
  * service name.
  * */
  get queue() {
    $.utils.testWhich("queue", $.utils.getUint16(0, this), 13, this);
    return $.utils.getStruct(1, ServiceDesignator, this);
  }
  _hasQueue() {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initQueue() {
    $.utils.setUint16(0, 13, this);
    return $.utils.initStructAt(1, ServiceDesignator, this);
  }
  get _isQueue() {
    return $.utils.getUint16(0, this) === 13;
  }
  set queue(value) {
    $.utils.setUint16(0, 13, this);
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  /**
  * Takes the value of an environment variable from the system. The value specified here is
  * the name of a system environment variable. The value of the binding is obtained by invoking
  * `getenv()` with that name. If the environment variable isn't set, the binding value is
  * `null`.
  * */
  get fromEnvironment() {
    $.utils.testWhich("fromEnvironment", $.utils.getUint16(0, this), 14, this);
    return $.utils.getText(1, this);
  }
  get _isFromEnvironment() {
    return $.utils.getUint16(0, this) === 14;
  }
  set fromEnvironment(value) {
    $.utils.setUint16(0, 14, this);
    $.utils.setText(1, value, this);
  }
  _adoptAnalyticsEngine(value) {
    $.utils.setUint16(0, 15, this);
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownAnalyticsEngine() {
    return $.utils.disown(this.analyticsEngine);
  }
  /**
  * A binding for Analytics Engine. Allows workers to store information through Analytics Engine Events.
  * workerd will forward AnalyticsEngineEvents to designated service in the body of HTTP requests
  * This binding is subject to change and requires the `--experimental` flag
  * */
  get analyticsEngine() {
    $.utils.testWhich("analyticsEngine", $.utils.getUint16(0, this), 15, this);
    return $.utils.getStruct(1, ServiceDesignator, this);
  }
  _hasAnalyticsEngine() {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initAnalyticsEngine() {
    $.utils.setUint16(0, 15, this);
    return $.utils.initStructAt(1, ServiceDesignator, this);
  }
  get _isAnalyticsEngine() {
    return $.utils.getUint16(0, this) === 15;
  }
  set analyticsEngine(value) {
    $.utils.setUint16(0, 15, this);
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  /**
  * A binding for Hyperdrive. Allows workers to use Hyperdrive caching & pooling for Postgres
  * databases.
  * */
  get hyperdrive() {
    $.utils.testWhich("hyperdrive", $.utils.getUint16(0, this), 16, this);
    return $.utils.getAs(Worker_Binding_Hyperdrive, this);
  }
  _initHyperdrive() {
    $.utils.setUint16(0, 16, this);
    return $.utils.getAs(Worker_Binding_Hyperdrive, this);
  }
  get _isHyperdrive() {
    return $.utils.getUint16(0, this) === 16;
  }
  set hyperdrive(_) {
    $.utils.setUint16(0, 16, this);
  }
  get _isUnsafeEval() {
    return $.utils.getUint16(0, this) === 17;
  }
  set unsafeEval(_) {
    $.utils.setUint16(0, 17, this);
  }
  /**
  * A binding representing access to an in-memory cache.
  * */
  get memoryCache() {
    $.utils.testWhich("memoryCache", $.utils.getUint16(0, this), 18, this);
    return $.utils.getAs(Worker_Binding_MemoryCache, this);
  }
  _initMemoryCache() {
    $.utils.setUint16(0, 18, this);
    return $.utils.getAs(Worker_Binding_MemoryCache, this);
  }
  get _isMemoryCache() {
    return $.utils.getUint16(0, this) === 18;
  }
  set memoryCache(_) {
    $.utils.setUint16(0, 18, this);
  }
  toString() {
    return "Worker_Binding_" + super.toString();
  }
  which() {
    return $.utils.getUint16(0, this);
  }
}
export const Worker_DurableObjectNamespace_Which = {
  UNIQUE_KEY: 0,
  EPHEMERAL_LOCAL: 1
};
export class Worker_DurableObjectNamespace extends $.Struct {
  static UNIQUE_KEY = Worker_DurableObjectNamespace_Which.UNIQUE_KEY;
  static EPHEMERAL_LOCAL = Worker_DurableObjectNamespace_Which.EPHEMERAL_LOCAL;
  static _capnp = {
    displayName: "DurableObjectNamespace",
    id: "b429dd547d15747d",
    size: new $.ObjectSize(8, 2)
  };
  /**
  * Exported class name that implements the Durable Object.
  *
  * Changing the class name will not break compatibility with existing storage, so long as
  * `uniqueKey` stays the same.
  * */
  get className() {
    return $.utils.getText(0, this);
  }
  set className(value) {
    $.utils.setText(0, value, this);
  }
  /**
  * A unique, stable ID associated with this namespace. This could be a  GUID, or any other
  * string which does not appear anywhere else in the world.
  *
  * This string is used to ensure that objects of this class have unique identifiers distinct
  * from objects of any other class. Object IDs are cryptographically derived from `uniqueKey`
  * and validated against it. It is impossible to guess or forge a valid object ID without
  * knowing the `uniqueKey`. Hence, if you keep the key secret, you can prevent anyone from
  * forging IDs. However, if you don't care if users can forge valid IDs, then it's not a big
  * deal if the key leaks.
  *
  * DO NOT LOSE this key, otherwise it may be difficult or impossible to recover stored data.
  * */
  get uniqueKey() {
    $.utils.testWhich("uniqueKey", $.utils.getUint16(0, this), 0, this);
    return $.utils.getText(1, this);
  }
  get _isUniqueKey() {
    return $.utils.getUint16(0, this) === 0;
  }
  set uniqueKey(value) {
    $.utils.setUint16(0, 0, this);
    $.utils.setText(1, value, this);
  }
  get _isEphemeralLocal() {
    return $.utils.getUint16(0, this) === 1;
  }
  set ephemeralLocal(_) {
    $.utils.setUint16(0, 1, this);
  }
  /**
  * By default, Durable Objects are evicted after 10 seconds of inactivity, and expire 70 seconds
  * after all clients have disconnected. Some applications may want to keep their Durable Objects
  * pinned to memory forever, so we provide this flag to change the default behavior.
  *
  * Note that this is only supported in Workerd; production Durable Objects cannot toggle eviction.
  * */
  get preventEviction() {
    return $.utils.getBit(16, this);
  }
  set preventEviction(value) {
    $.utils.setBit(16, value, this);
  }
  toString() {
    return "Worker_DurableObjectNamespace_" + super.toString();
  }
  which() {
    return $.utils.getUint16(0, this);
  }
}
export const Worker_DurableObjectStorage_Which = {
  NONE: 0,
  IN_MEMORY: 1,
  LOCAL_DISK: 2
};
/**
* Specifies where this worker's Durable Objects are stored.
* */
export class Worker_DurableObjectStorage extends $.Struct {
  static NONE = Worker_DurableObjectStorage_Which.NONE;
  static IN_MEMORY = Worker_DurableObjectStorage_Which.IN_MEMORY;
  static LOCAL_DISK = Worker_DurableObjectStorage_Which.LOCAL_DISK;
  static _capnp = {
    displayName: "durableObjectStorage",
    id: "cc72b3faa57827d4",
    size: new $.ObjectSize(8, 10)
  };
  get _isNone() {
    return $.utils.getUint16(2, this) === 0;
  }
  set none(_) {
    $.utils.setUint16(2, 0, this);
  }
  get _isInMemory() {
    return $.utils.getUint16(2, this) === 1;
  }
  set inMemory(_) {
    $.utils.setUint16(2, 1, this);
  }
  /**
  * ** EXPERIMENTAL; SUBJECT TO BACKWARDS-INCOMPATIBLE CHANGE **
  *
  * Durable Object data will be stored in a directory on local disk. This field is the name of
  * a service, which must be a DiskDirectory service. For each Durable Object class, a
  * subdirectory will be created using `uniqueKey` as the name. Within the directory, one or
  * more files are created for each object, with names `<id>.<ext>`, where `.<ext>` may be any of
  * a number of different extensions depending on the storage mode. (Currently, the main storage
  * is a file with the extension `.sqlite`, and in certain situations extra files with the
  * extensions `.sqlite-wal`, and `.sqlite-shm` may also be present.)
  * */
  get localDisk() {
    $.utils.testWhich("localDisk", $.utils.getUint16(2, this), 2, this);
    return $.utils.getText(8, this);
  }
  get _isLocalDisk() {
    return $.utils.getUint16(2, this) === 2;
  }
  set localDisk(value) {
    $.utils.setUint16(2, 2, this);
    $.utils.setText(8, value, this);
  }
  toString() {
    return "Worker_DurableObjectStorage_" + super.toString();
  }
  which() {
    return $.utils.getUint16(2, this);
  }
}
export const Worker_Which = {
  MODULES: 0,
  SERVICE_WORKER_SCRIPT: 1,
  INHERIT: 2
};
export class Worker extends $.Struct {
  static MODULES = Worker_Which.MODULES;
  static SERVICE_WORKER_SCRIPT = Worker_Which.SERVICE_WORKER_SCRIPT;
  static INHERIT = Worker_Which.INHERIT;
  static Module = Worker_Module;
  static Binding = Worker_Binding;
  static DurableObjectNamespace = Worker_DurableObjectNamespace;
  static _capnp = {
    displayName: "Worker",
    id: "acfa77e88fd97d1c",
    size: new $.ObjectSize(8, 10),
    defaultGlobalOutbound: $.readRawPointer(new Uint8Array([0x10, 0x05, 0x40, 0x02, 0x11, 0x05, 0x4a, 0x00, 0x00, 0xff, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x00, 0x00, 0x00]).buffer)
  };
  static _Modules;
  static _Bindings;
  static _DurableObjectNamespaces;
  _adoptModules(value) {
    $.utils.setUint16(0, 0, this);
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownModules() {
    return $.utils.disown(this.modules);
  }
  /**
  * The Worker is composed of ES modules that may import each other. The first module in the list
  * is the main module, which exports event handlers.
  * */
  get modules() {
    $.utils.testWhich("modules", $.utils.getUint16(0, this), 0, this);
    return $.utils.getList(0, Worker._Modules, this);
  }
  _hasModules() {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initModules(length) {
    $.utils.setUint16(0, 0, this);
    return $.utils.initList(0, Worker._Modules, length, this);
  }
  get _isModules() {
    return $.utils.getUint16(0, this) === 0;
  }
  set modules(value) {
    $.utils.setUint16(0, 0, this);
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  /**
  * The Worker is composed of one big script that uses global `addEventListener()` to register
  * event handlers.
  *
  * The value of this field is the raw source code. When using Cap'n Proto text format, use the
  * `embed` directive to read the code from an exnternal file:
  *
  *     serviceWorkerScript = embed "worker.js"
  * */
  get serviceWorkerScript() {
    $.utils.testWhich("serviceWorkerScript", $.utils.getUint16(0, this), 1, this);
    return $.utils.getText(0, this);
  }
  get _isServiceWorkerScript() {
    return $.utils.getUint16(0, this) === 1;
  }
  set serviceWorkerScript(value) {
    $.utils.setUint16(0, 1, this);
    $.utils.setText(0, value, this);
  }
  /**
  * Inherit the configuration of some other Worker by its service name. This Worker is a clone
  * of the other worker, but various settings can be modified:
  * * `bindings`, if specified, overrides specific named bindings. (Each binding listed in the
  *   derived worker must match the name and type of some binding in the inherited worker.)
  * * `globalOutbound`, if non-null, overrides the one specified in the inherited worker.
  * * `compatibilityDate` and `compatibilityFlags` CANNOT be modified; they must be null.
  * * If the inherited worker defines durable object namespaces, then the derived worker must
  *   specify `durableObjectStorage` to specify where its instances should be stored. Each
  *   devived worker receives its own namespace of objects. `durableObjectUniqueKeyModifier`
  *   must also be specified by derived workers.
  *
  * This can be useful when you want to run the same Worker in multiple configurations or hooked
  * up to different back-ends. Note that all derived workers run in the same isolate as the
  * base worker; they differ in the content of the `env` object passed to them, which contains
  * the bindings. (When using service workers syntax, the global scope contains the bindings;
  * in this case each derived worker runs in its own global scope, though still in the same
  * isolate.)
  * */
  get inherit() {
    $.utils.testWhich("inherit", $.utils.getUint16(0, this), 2, this);
    return $.utils.getText(0, this);
  }
  get _isInherit() {
    return $.utils.getUint16(0, this) === 2;
  }
  set inherit(value) {
    $.utils.setUint16(0, 2, this);
    $.utils.setText(0, value, this);
  }
  get compatibilityDate() {
    return $.utils.getText(1, this);
  }
  set compatibilityDate(value) {
    $.utils.setText(1, value, this);
  }
  _adoptCompatibilityFlags(value) {
    $.utils.adopt(value, $.utils.getPointer(2, this));
  }
  _disownCompatibilityFlags() {
    return $.utils.disown(this.compatibilityFlags);
  }
  /**
  * See: https://developers.cloudflare.com/workers/platform/compatibility-dates/
  *
  * `compatibilityDate` must be specified, unless the Worker inhits from another worker, in which
  * case it must not be specified. `compatibilityFlags` can optionally be specified when
  * `compatibilityDate` is specified.
  * */
  get compatibilityFlags() {
    return $.utils.getList(2, $.TextList, this);
  }
  _hasCompatibilityFlags() {
    return !$.utils.isNull($.utils.getPointer(2, this));
  }
  _initCompatibilityFlags(length) {
    return $.utils.initList(2, $.TextList, length, this);
  }
  set compatibilityFlags(value) {
    $.utils.copyFrom(value, $.utils.getPointer(2, this));
  }
  _adoptBindings(value) {
    $.utils.adopt(value, $.utils.getPointer(3, this));
  }
  _disownBindings() {
    return $.utils.disown(this.bindings);
  }
  /**
  * List of bindings, which give the Worker access to external resources and configuration
  * settings.
  *
  * For Workers using ES modules syntax, the bindings are delivered via the `env` object. For
  * service workers syntax, each binding shows up as a global variable.
  * */
  get bindings() {
    return $.utils.getList(3, Worker._Bindings, this);
  }
  _hasBindings() {
    return !$.utils.isNull($.utils.getPointer(3, this));
  }
  _initBindings(length) {
    return $.utils.initList(3, Worker._Bindings, length, this);
  }
  set bindings(value) {
    $.utils.copyFrom(value, $.utils.getPointer(3, this));
  }
  _adoptGlobalOutbound(value) {
    $.utils.adopt(value, $.utils.getPointer(4, this));
  }
  _disownGlobalOutbound() {
    return $.utils.disown(this.globalOutbound);
  }
  /**
  * Where should the global "fetch" go to? The default is the service called "internet", which
  * should usually be configured to talk to the public internet.
  * */
  get globalOutbound() {
    return $.utils.getStruct(4, ServiceDesignator, this, Worker._capnp.defaultGlobalOutbound);
  }
  _hasGlobalOutbound() {
    return !$.utils.isNull($.utils.getPointer(4, this));
  }
  _initGlobalOutbound() {
    return $.utils.initStructAt(4, ServiceDesignator, this);
  }
  set globalOutbound(value) {
    $.utils.copyFrom(value, $.utils.getPointer(4, this));
  }
  _adoptCacheApiOutbound(value) {
    $.utils.adopt(value, $.utils.getPointer(7, this));
  }
  _disownCacheApiOutbound() {
    return $.utils.disown(this.cacheApiOutbound);
  }
  /**
  * List of durable object namespaces in this Worker.
  * */
  get cacheApiOutbound() {
    return $.utils.getStruct(7, ServiceDesignator, this);
  }
  _hasCacheApiOutbound() {
    return !$.utils.isNull($.utils.getPointer(7, this));
  }
  _initCacheApiOutbound() {
    return $.utils.initStructAt(7, ServiceDesignator, this);
  }
  set cacheApiOutbound(value) {
    $.utils.copyFrom(value, $.utils.getPointer(7, this));
  }
  _adoptDurableObjectNamespaces(value) {
    $.utils.adopt(value, $.utils.getPointer(5, this));
  }
  _disownDurableObjectNamespaces() {
    return $.utils.disown(this.durableObjectNamespaces);
  }
  /**
  * Additional text which is hashed together with `DurableObjectNamespace.uniqueKey`. When using
  * worker inheritance, each derived worker must specify a unique modifier to ensure that its
  * Durable Object instances have unique IDs from all other workers inheriting the same parent.
  *
  * DO NOT LOSE this value, otherwise it may be difficult or impossible to recover stored data.
  * */
  get durableObjectNamespaces() {
    return $.utils.getList(5, Worker._DurableObjectNamespaces, this);
  }
  _hasDurableObjectNamespaces() {
    return !$.utils.isNull($.utils.getPointer(5, this));
  }
  _initDurableObjectNamespaces(length) {
    return $.utils.initList(5, Worker._DurableObjectNamespaces, length, this);
  }
  set durableObjectNamespaces(value) {
    $.utils.copyFrom(value, $.utils.getPointer(5, this));
  }
  /**
  * Specifies where this worker's Durable Objects are stored.
  * */
  get durableObjectUniqueKeyModifier() {
    return $.utils.getText(6, this);
  }
  set durableObjectUniqueKeyModifier(value) {
    $.utils.setText(6, value, this);
  }
  /**
  * Where should cache API (i.e. caches.default and caches.open(...)) requests go?
  * */
  get durableObjectStorage() {
    return $.utils.getAs(Worker_DurableObjectStorage, this);
  }
  _initDurableObjectStorage() {
    return $.utils.getAs(Worker_DurableObjectStorage, this);
  }
  get moduleFallback() {
    return $.utils.getText(9, this);
  }
  set moduleFallback(value) {
    $.utils.setText(9, value, this);
  }
  toString() {
    return "Worker_" + super.toString();
  }
  which() {
    return $.utils.getUint16(0, this);
  }
}
/**
* Talk to the server over encrypted HTTPS.
* */
export class ExternalServer_Https extends $.Struct {
  static _capnp = {
    displayName: "https",
    id: "ac37e02afd3dc6db",
    size: new $.ObjectSize(8, 4)
  };
  _adoptOptions(value) {
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownOptions() {
    return $.utils.disown(this.options);
  }
  get options() {
    return $.utils.getStruct(1, HttpOptions, this);
  }
  _hasOptions() {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initOptions() {
    return $.utils.initStructAt(1, HttpOptions, this);
  }
  set options(value) {
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  _adoptTlsOptions(value) {
    $.utils.adopt(value, $.utils.getPointer(2, this));
  }
  _disownTlsOptions() {
    return $.utils.disown(this.tlsOptions);
  }
  get tlsOptions() {
    return $.utils.getStruct(2, TlsOptions, this);
  }
  _hasTlsOptions() {
    return !$.utils.isNull($.utils.getPointer(2, this));
  }
  _initTlsOptions() {
    return $.utils.initStructAt(2, TlsOptions, this);
  }
  set tlsOptions(value) {
    $.utils.copyFrom(value, $.utils.getPointer(2, this));
  }
  /**
  * If present, expect the host to present a certificate authenticating it as this hostname.
  * If `certificateHost` is not provided, then the certificate is checked against `address`.
  * */
  get certificateHost() {
    return $.utils.getText(3, this);
  }
  set certificateHost(value) {
    $.utils.setText(3, value, this);
  }
  toString() {
    return "ExternalServer_Https_" + super.toString();
  }
}
/**
* Connect to the server over raw TCP. Bindings to this service will only support the
* `connect()` method; `fetch()` will throw an exception.
* */
export class ExternalServer_Tcp extends $.Struct {
  static _capnp = {
    displayName: "tcp",
    id: "d941637df0fb39f1",
    size: new $.ObjectSize(8, 4)
  };
  _adoptTlsOptions(value) {
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownTlsOptions() {
    return $.utils.disown(this.tlsOptions);
  }
  get tlsOptions() {
    return $.utils.getStruct(1, TlsOptions, this);
  }
  _hasTlsOptions() {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initTlsOptions() {
    return $.utils.initStructAt(1, TlsOptions, this);
  }
  set tlsOptions(value) {
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  get certificateHost() {
    return $.utils.getText(2, this);
  }
  set certificateHost(value) {
    $.utils.setText(2, value, this);
  }
  toString() {
    return "ExternalServer_Tcp_" + super.toString();
  }
}
export const ExternalServer_Which = {
  HTTP: 0,
  HTTPS: 1,
  TCP: 2
};
/**
* Describes the ability to talk to a specific server, typically a back-end server available
* on the internal network.
*
* When a Worker contains a service binding that points to an ExternalServer, *all* fetch()
* calls on that binding will be delivered to that server, regardless of whether the hostname
* or protocol specified in the URL actually match the hostname or protocol used by the actual
* server. Typically, a Worker implementing a reverse proxy would use this to forward a request
* to a back-end application server. Such a back-end typically does not have a real public
* hostname, since it is only reachable through the proxy, but the requests forwarded to it will
* keep the hostname that was on the original request.
*
* Note that this also implies that regardless of whether the original URL was http: or https:,
* the request will be delivered to the target server using the protocol specified below. A
* header like `X-Forwarded-Proto` can be used to pass along the original protocol; see
* `HttpOptions`.
* */
export class ExternalServer extends $.Struct {
  static HTTP = ExternalServer_Which.HTTP;
  static HTTPS = ExternalServer_Which.HTTPS;
  static TCP = ExternalServer_Which.TCP;
  static _capnp = {
    displayName: "ExternalServer",
    id: "ff209f9aa352f5a4",
    size: new $.ObjectSize(8, 4)
  };
  /**
  * Address/port of the server. Optional; if not specified, then you will be required to specify
  * the address on the command line with with `--external-addr <name>=<addr>`.
  *
  * Examples:
  * - "1.2.3.4": Connect to the given IPv4 address on the protocol's default port.
  * - "1.2.3.4:80": Connect to the given IPv4 address and port.
  * - "1234:5678::abcd": Connect to the given IPv6 address on the protocol's default port.
  * - "[1234:5678::abcd]:80": Connect to the given IPv6 address and port.
  * - "unix:/path/to/socket": Connect to the given Unix Domain socket by path.
  * - "unix-abstract:name": On Linux, connect to the given "abstract" Unix socket name.
  * - "example.com:80": Perform a DNS lookup to determine the address, and then connect to it.
  *
  * (These are the formats supported by KJ's parseAddress().)
  * */
  get address() {
    return $.utils.getText(0, this);
  }
  set address(value) {
    $.utils.setText(0, value, this);
  }
  _adoptHttp(value) {
    $.utils.setUint16(0, 0, this);
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownHttp() {
    return $.utils.disown(this.http);
  }
  /**
  * Talk to the server over unencrypted HTTP.
  * */
  get http() {
    $.utils.testWhich("http", $.utils.getUint16(0, this), 0, this);
    return $.utils.getStruct(1, HttpOptions, this);
  }
  _hasHttp() {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initHttp() {
    $.utils.setUint16(0, 0, this);
    return $.utils.initStructAt(1, HttpOptions, this);
  }
  get _isHttp() {
    return $.utils.getUint16(0, this) === 0;
  }
  set http(value) {
    $.utils.setUint16(0, 0, this);
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  /**
  * Talk to the server over encrypted HTTPS.
  * */
  get https() {
    $.utils.testWhich("https", $.utils.getUint16(0, this), 1, this);
    return $.utils.getAs(ExternalServer_Https, this);
  }
  _initHttps() {
    $.utils.setUint16(0, 1, this);
    return $.utils.getAs(ExternalServer_Https, this);
  }
  get _isHttps() {
    return $.utils.getUint16(0, this) === 1;
  }
  set https(_) {
    $.utils.setUint16(0, 1, this);
  }
  /**
  * Connect to the server over raw TCP. Bindings to this service will only support the
  * `connect()` method; `fetch()` will throw an exception.
  * */
  get tcp() {
    $.utils.testWhich("tcp", $.utils.getUint16(0, this), 2, this);
    return $.utils.getAs(ExternalServer_Tcp, this);
  }
  _initTcp() {
    $.utils.setUint16(0, 2, this);
    return $.utils.getAs(ExternalServer_Tcp, this);
  }
  get _isTcp() {
    return $.utils.getUint16(0, this) === 2;
  }
  set tcp(_) {
    $.utils.setUint16(0, 2, this);
  }
  toString() {
    return "ExternalServer_" + super.toString();
  }
  which() {
    return $.utils.getUint16(0, this);
  }
}
/**
* Describes the ability to talk to a network.
*
* This is commonly used to define the "internet" service which is the default `globalOutbound`
* for all Workers. To prevent SSRF, by default Workers will not be permitted to reach internal
* network addresses using global fetch(). It's recommended that you create ExternalServer
* bindings instead to grant access to specific servers. However, if you really want to, you
* can configure a service that grants arbitrary internal network access, like:
*
*     ( name = "internalNetwork",
*       network = (
*         allow = ["public", "private"],
*       )
*     )
* */
export class Network extends $.Struct {
  static _capnp = {
    displayName: "Network",
    id: "fa42244f950c9b9c",
    size: new $.ObjectSize(0, 3),
    defaultAllow: $.readRawPointer(new Uint8Array([0x10, 0x03, 0x11, 0x01, 0x0e, 0x11, 0x01, 0x3a, 0x3f, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63]).buffer)
  };
  _adoptAllow(value) {
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownAllow() {
    return $.utils.disown(this.allow);
  }
  get allow() {
    return $.utils.getList(0, $.TextList, this, Network._capnp.defaultAllow);
  }
  _hasAllow() {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initAllow(length) {
    return $.utils.initList(0, $.TextList, length, this);
  }
  set allow(value) {
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  _adoptDeny(value) {
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownDeny() {
    return $.utils.disown(this.deny);
  }
  /**
  * Specifies which network addresses the Worker will be allowed to connect to, e.g. using fetch().
  * The default allows publicly-routable IP addresses only, in order to prevent SSRF attacks.
  *
  * The allow and deny lists specify network blocks in CIDR notation (IPv4 and IPv6), such as
  * "192.0.2.0/24" or "2001:db8::/32". Traffic will be permitted as long as the address
  * matches at least one entry in the allow list and none in the deny list.
  *
  * In addition to IPv4 and IPv6 CIDR notation, several special strings may be specified:
  * - "private": Matches network addresses that are reserved by standards for private networks,
  *   such as "10.0.0.0/8" or "192.168.0.0/16". This is a superset of "local".
  * - "public": Opposite of "private".
  * - "local": Matches network addresses that are defined by standards to only be accessible from
  *   the local machine, such as "127.0.0.0/8" or Unix domain addresses.
  * - "network": Opposite of "local".
  * - "unix": Matches all Unix domain socket addresses. (In the future, we may support specifying a
  *   glob to narrow this to specific paths.)
  * - "unix-abstract": Matches Linux's "abstract unix domain" addresses. (In the future, we may
  *   support specifying a glob.)
  *
  * In the case that the Worker specifies a DNS hostname rather than a raw address, these rules are
  * used to filter the addresses returned by the lookup. If none of the returned addresses turn
  * out to be permitted, then the system will behave as if the DNS entry did not exist.
  *
  * (The above is exactly the format supported by kj::Network::restrictPeers().)
  * */
  get deny() {
    return $.utils.getList(1, $.TextList, this);
  }
  _hasDeny() {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initDeny(length) {
    return $.utils.initList(1, $.TextList, length, this);
  }
  set deny(value) {
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  _adoptTlsOptions(value) {
    $.utils.adopt(value, $.utils.getPointer(2, this));
  }
  _disownTlsOptions() {
    return $.utils.disown(this.tlsOptions);
  }
  get tlsOptions() {
    return $.utils.getStruct(2, TlsOptions, this);
  }
  _hasTlsOptions() {
    return !$.utils.isNull($.utils.getPointer(2, this));
  }
  _initTlsOptions() {
    return $.utils.initStructAt(2, TlsOptions, this);
  }
  set tlsOptions(value) {
    $.utils.copyFrom(value, $.utils.getPointer(2, this));
  }
  toString() {
    return "Network_" + super.toString();
  }
}
/**
* Configures access to a directory on disk. This is a type of service which will expose an HTTP
* interface to the directory content.
*
* This is very bare-bones, generally not suitable for serving a web site on its own. In
* particular, no attempt is made to guess the `Content-Type` header. You normally would wrap
* this in a Worker that fills in the metadata in the way you want.
*
* A GET request targetting a directory (rather than a file) will return a basic JSAN directory
* listing like:
*
*     [{"name":"foo","type":"file"},{"name":"bar","type":"directory"}]
*
* Possible "type" values are "file", "directory", "symlink", "blockDevice", "characterDevice",
* "namedPipe", "socket", "other".
*
* `Content-Type` will be `application/octet-stream` for files or `application/json` for a
* directory listing. Files will have a `Content-Length` header, directories will not. Symlinks
* will be followed (but there is intentionally no way to create one, even if `writable` is
* `true`), and treated according to the type of file they point to. The other inode types cannot
* be opened; trying to do so will produce a "406 Not Acceptable" error (on the theory that there
* is no acceptable format for these, regardless of what the client says it accepts).
*
* `HEAD` requests are properly optimized to perform a stat() without actually opening the file.
* */
export class DiskDirectory extends $.Struct {
  static _capnp = {
    displayName: "DiskDirectory",
    id: "9048ab22835f51c3",
    size: new $.ObjectSize(8, 1),
    defaultWritable: $.getBitMask(false, 0),
    defaultAllowDotfiles: $.getBitMask(false, 1)
  };
  /**
  * The filesystem path of the directory. If not specified, then it must be specified on the
  * command line with `--directory-path <service-name>=<path>`.
  *
  * Relative paths are interpreted relative to the current directory where the server is executed,
  * NOT relative to the config file. So, you should usually use absolute paths in the config file.
  * */
  get path() {
    return $.utils.getText(0, this);
  }
  set path(value) {
    $.utils.setText(0, value, this);
  }
  /**
  * Whether to support PUT requests for writing. A PUT will write to a temporary file which
  * is atomically moved into place upon successful completion of the upload. Parent directories are
  * created as needed.
  * */
  get writable() {
    return $.utils.getBit(0, this, DiskDirectory._capnp.defaultWritable);
  }
  set writable(value) {
    $.utils.setBit(0, value, this, DiskDirectory._capnp.defaultWritable);
  }
  /**
  * Whether to allow access to files and directories whose name starts with '.'. These are made
  * inaccessible by default since they very often store metadata that is not meant to be served,
  * e.g. a git repository or an `.htaccess` file.
  *
  * Note that the special links "." and ".." will never be accessible regardless of this setting.
  * */
  get allowDotfiles() {
    return $.utils.getBit(1, this, DiskDirectory._capnp.defaultAllowDotfiles);
  }
  set allowDotfiles(value) {
    $.utils.setBit(1, value, this, DiskDirectory._capnp.defaultAllowDotfiles);
  }
  toString() {
    return "DiskDirectory_" + super.toString();
  }
}
export const HttpOptions_Style = {
  HOST: 0,
  PROXY: 1
};
export class HttpOptions_Header extends $.Struct {
  static _capnp = {
    displayName: "Header",
    id: "dc0394b5a6f3417e",
    size: new $.ObjectSize(0, 2)
  };
  /**
  * Case-insensitive.
  * */
  get name() {
    return $.utils.getText(0, this);
  }
  set name(value) {
    $.utils.setText(0, value, this);
  }
  /**
  * If null, the header will be removed.
  * */
  get value() {
    return $.utils.getText(1, this);
  }
  set value(value) {
    $.utils.setText(1, value, this);
  }
  toString() {
    return "HttpOptions_Header_" + super.toString();
  }
}
/**
* Options for using HTTP (as a client or server). In particular, this specifies behavior that is
* important in the presence of proxy servers, whether forward or reverse.
* */
export class HttpOptions extends $.Struct {
  static Style = HttpOptions_Style;
  static Header = HttpOptions_Header;
  static _capnp = {
    displayName: "HttpOptions",
    id: "aa8dc6885da78f19",
    size: new $.ObjectSize(8, 5),
    defaultStyle: $.getUint16Mask(0)
  };
  static _InjectRequestHeaders;
  static _InjectResponseHeaders;
  get style() {
    return $.utils.getUint16(0, this, HttpOptions._capnp.defaultStyle);
  }
  set style(value) {
    $.utils.setUint16(0, value, this, HttpOptions._capnp.defaultStyle);
  }
  /**
  * If specified, then when the given header is present on a request, it specifies the protocol
  * ("http" or "https") that was used by the original client. The request URL reported to the
  * Worker will reflect this protocol. Otherwise, the URL will reflect the actual physical protocol
  * used by the server in receiving the request.
  *
  * This option is useful when this server sits behind a reverse proxy that performs TLS
  * termination. Typically such proxies forward the original protocol in a header named something
  * like "X-Forwarded-Proto".
  *
  * This setting is ignored when `style` is `proxy`.
  * */
  get forwardedProtoHeader() {
    return $.utils.getText(0, this);
  }
  set forwardedProtoHeader(value) {
    $.utils.setText(0, value, this);
  }
  /**
  * If set, then the `request.cf` object will be encoded (as JSON) into / parsed from the header
  * with this name. Otherwise, it will be discarded on send / `undefined` on receipt.
  * */
  get cfBlobHeader() {
    return $.utils.getText(1, this);
  }
  set cfBlobHeader(value) {
    $.utils.setText(1, value, this);
  }
  _adoptInjectRequestHeaders(value) {
    $.utils.adopt(value, $.utils.getPointer(2, this));
  }
  _disownInjectRequestHeaders() {
    return $.utils.disown(this.injectRequestHeaders);
  }
  /**
  * List of headers which will be automatically injected into all requests. This can be used
  * e.g. to add an authorization token to all requests when using `ExternalServer`. It can also
  * apply to incoming requests received on a `Socket` to modify the headers that will be delivered
  * to the app. Any existing header with the same name is removed.
  * */
  get injectRequestHeaders() {
    return $.utils.getList(2, HttpOptions._InjectRequestHeaders, this);
  }
  _hasInjectRequestHeaders() {
    return !$.utils.isNull($.utils.getPointer(2, this));
  }
  _initInjectRequestHeaders(length) {
    return $.utils.initList(2, HttpOptions._InjectRequestHeaders, length, this);
  }
  set injectRequestHeaders(value) {
    $.utils.copyFrom(value, $.utils.getPointer(2, this));
  }
  _adoptInjectResponseHeaders(value) {
    $.utils.adopt(value, $.utils.getPointer(3, this));
  }
  _disownInjectResponseHeaders() {
    return $.utils.disown(this.injectResponseHeaders);
  }
  /**
  * Same as `injectRequestHeaders` but for responses.
  * */
  get injectResponseHeaders() {
    return $.utils.getList(3, HttpOptions._InjectResponseHeaders, this);
  }
  _hasInjectResponseHeaders() {
    return !$.utils.isNull($.utils.getPointer(3, this));
  }
  _initInjectResponseHeaders(length) {
    return $.utils.initList(3, HttpOptions._InjectResponseHeaders, length, this);
  }
  set injectResponseHeaders(value) {
    $.utils.copyFrom(value, $.utils.getPointer(3, this));
  }
  /**
  * A CONNECT request for this host+port will be treated as a request to form a Cap'n Proto RPC
  * connection. The server will expose a WorkerdBootstrap as the bootstrap interface, allowing
  * events to be delivered to the target worker via capnp. Clients will use capnp for non-HTTP
  * event types (especially JSRPC).
  * */
  get capnpConnectHost() {
    return $.utils.getText(4, this);
  }
  set capnpConnectHost(value) {
    $.utils.setText(4, value, this);
  }
  toString() {
    return "HttpOptions_" + super.toString();
  }
}
export class TlsOptions_Keypair extends $.Struct {
  static _capnp = {
    displayName: "Keypair",
    id: "f546bf2d5d8bd13e",
    size: new $.ObjectSize(0, 2)
  };
  /**
  * Private key in PEM format. Supports PKCS8 keys as well as "traditional format" RSA and DSA
  * keys.
  *
  * Remember that you can use Cap'n Proto's `embed` syntax to reference an external file.
  * */
  get privateKey() {
    return $.utils.getText(0, this);
  }
  set privateKey(value) {
    $.utils.setText(0, value, this);
  }
  /**
  * Certificate chain in PEM format. A chain can be constructed by concatenating multiple
  * PEM-encoded certificates, starting with the leaf certificate.
  * */
  get certificateChain() {
    return $.utils.getText(1, this);
  }
  set certificateChain(value) {
    $.utils.setText(1, value, this);
  }
  toString() {
    return "TlsOptions_Keypair_" + super.toString();
  }
}
export const TlsOptions_Version = {
  GOOD_DEFAULT: 0,
  SSL3: 1,
  TLS1DOT0: 2,
  TLS1DOT1: 3,
  TLS1DOT2: 4,
  TLS1DOT3: 5
};
/**
* Options that apply when using TLS. Can apply on either the client or the server side, depending
* on the context.
*
* This is based on KJ's TlsContext::Options.
* */
export class TlsOptions extends $.Struct {
  static Keypair = TlsOptions_Keypair;
  static Version = TlsOptions_Version;
  static _capnp = {
    displayName: "TlsOptions",
    id: "aabb3c3778ac4311",
    size: new $.ObjectSize(8, 3),
    defaultRequireClientCerts: $.getBitMask(false, 0),
    defaultTrustBrowserCas: $.getBitMask(false, 1),
    defaultMinVersion: $.getUint16Mask(0)
  };
  _adoptKeypair(value) {
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownKeypair() {
    return $.utils.disown(this.keypair);
  }
  /**
  * The default private key and certificate to use. Optional when acting as a client.
  * */
  get keypair() {
    return $.utils.getStruct(0, TlsOptions_Keypair, this);
  }
  _hasKeypair() {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initKeypair() {
    return $.utils.initStructAt(0, TlsOptions_Keypair, this);
  }
  set keypair(value) {
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  /**
  * If true, then when acting as a server, incoming connections will be rejected unless they bear
  * a certificate signed by one of the trusted CAs.
  *
  * Typically, when using this, you'd set `trustBrowserCas = false` and list a specific private CA
  * in `trustedCertificates`.
  * */
  get requireClientCerts() {
    return $.utils.getBit(0, this, TlsOptions._capnp.defaultRequireClientCerts);
  }
  set requireClientCerts(value) {
    $.utils.setBit(0, value, this, TlsOptions._capnp.defaultRequireClientCerts);
  }
  /**
  * If true, trust certificates which are signed by one of the CAs that browsers normally trust.
  * You should typically set this true when talking to the public internet, but you may want to
  * set it false when talking to servers on your internal network.
  * */
  get trustBrowserCas() {
    return $.utils.getBit(1, this, TlsOptions._capnp.defaultTrustBrowserCas);
  }
  set trustBrowserCas(value) {
    $.utils.setBit(1, value, this, TlsOptions._capnp.defaultTrustBrowserCas);
  }
  _adoptTrustedCertificates(value) {
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownTrustedCertificates() {
    return $.utils.disown(this.trustedCertificates);
  }
  /**
  * Additional CA certificates to trust, in PEM format. Remember that you can use Cap'n Proto's
  * `embed` syntax to read the certificates from other files.
  * */
  get trustedCertificates() {
    return $.utils.getList(1, $.TextList, this);
  }
  _hasTrustedCertificates() {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initTrustedCertificates(length) {
    return $.utils.initList(1, $.TextList, length, this);
  }
  set trustedCertificates(value) {
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  /**
  * Minimum TLS version that will be allowed. Generally you should not override this unless you
  * have unusual backwards-compatibility needs.
  * */
  get minVersion() {
    return $.utils.getUint16(2, this, TlsOptions._capnp.defaultMinVersion);
  }
  set minVersion(value) {
    $.utils.setUint16(2, value, this, TlsOptions._capnp.defaultMinVersion);
  }
  /**
  * OpenSSL cipher list string. The default is a curated list designed to be compatible with
  * almost all software in current use (specifically, based on Mozilla's "intermediate"
  * recommendations). The defaults will change in future versions of this software to account
  * for the latest cryptanalysis.
  *
  * Generally you should only specify your own `cipherList` if:
  * - You have extreme backwards-compatibility needs and wish to enable obsolete and/or broken
  *   algorithms.
  * - You need quickly to disable an algorithm recently discovered to be broken.
  * */
  get cipherList() {
    return $.utils.getText(2, this);
  }
  set cipherList(value) {
    $.utils.setText(2, value, this);
  }
  toString() {
    return "TlsOptions_" + super.toString();
  }
}
/**
* A module extending workerd functionality.
* */
export class Extension_Module extends $.Struct {
  static _capnp = {
    displayName: "Module",
    id: "d5d16e76fdedc37d",
    size: new $.ObjectSize(8, 2),
    defaultInternal: $.getBitMask(false, 0)
  };
  /**
  * Full js module name.
  * */
  get name() {
    return $.utils.getText(0, this);
  }
  set name(value) {
    $.utils.setText(0, value, this);
  }
  /**
  * Internal modules can be imported by other extension modules only and not the user code.
  * */
  get internal() {
    return $.utils.getBit(0, this, Extension_Module._capnp.defaultInternal);
  }
  set internal(value) {
    $.utils.setBit(0, value, this, Extension_Module._capnp.defaultInternal);
  }
  /**
  * Raw source code of ES module.
  * */
  get esModule() {
    return $.utils.getText(1, this);
  }
  set esModule(value) {
    $.utils.setText(1, value, this);
  }
  toString() {
    return "Extension_Module_" + super.toString();
  }
}
/**
* Additional capabilities for workers.
* */
export class Extension extends $.Struct {
  static Module = Extension_Module;
  static _capnp = {
    displayName: "Extension",
    id: "e390128a861973a6",
    size: new $.ObjectSize(0, 1)
  };
  static _Modules;
  _adoptModules(value) {
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownModules() {
    return $.utils.disown(this.modules);
  }
  /**
  * List of javascript modules provided by the extension.
  * These modules can either be imported directly as user-level api (if not marked internal)
  * or used to define more complicated workerd constructs such as wrapped bindings and events.
  * */
  get modules() {
    return $.utils.getList(0, Extension._Modules, this);
  }
  _hasModules() {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initModules(length) {
    return $.utils.initList(0, Extension._Modules, length, this);
  }
  set modules(value) {
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  toString() {
    return "Extension_" + super.toString();
  }
}
Config._Services = $.CompositeList(Service);
Config._Sockets = $.CompositeList(Socket);
Config._Extensions = $.CompositeList(Extension);
Worker_Binding_WrappedBinding._InnerBindings = $.CompositeList(Worker_Binding);
Worker._Modules = $.CompositeList(Worker_Module);
Worker._Bindings = $.CompositeList(Worker_Binding);
Worker._DurableObjectNamespaces = $.CompositeList(Worker_DurableObjectNamespace);
HttpOptions._InjectRequestHeaders = $.CompositeList(HttpOptions_Header);
HttpOptions._InjectResponseHeaders = $.CompositeList(HttpOptions_Header);
Extension._Modules = $.CompositeList(Extension_Module);
